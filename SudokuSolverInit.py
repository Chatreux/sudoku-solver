#--------------------------------Imports---------------------------------------#
import pygame, sys
from pygame.locals import *
import random
#--------------------------------Imports---------------------------------------#
## Things we need to add:
## - User inputs to the left grid (DONE)
## - Clear button for left grid (DONE)
## - Next logical value button
## - Total solve button (DONE)
## - Buttons to move between puzzles, ideally buttons for 'random', 'next' and
## 'previous' puzzles. (DONE)

## Things we should consider adding, time permitting: (SCRAP)
## - Optional timer 
## - Implement sideways solving, i. e., two player sudoku

## del solvedCells[:] called whenever a new puzzle is loaded, must be tested.
## Alternative is solvedCells = [], but this will not alter references.
## References are minimised - non existant- at this point, but provides an
## unresolved loose end.

## File loading could be optimised. Getting multiple call errors on closing



## NEXT
## Method to accept list, return reduced list without repeatitions. Order must
## be maintained. Iterating over the loop is O(n), which is not ideal.
## Preferably a predefined function should work, though most have conflicts with
## solvedCells[] global nature.
## NLV detects whether parse_grid() solves a puzzle (Never happens on first
## call) Runs solve to find values that parse_grid misses, appends with marker.
## Keeps iterating until the puzzle is solved. Calls above method on finishing
## to reduce solvedCells[].

#----------------------------------Solve Methods-------------------------------#
## These are the functions to solve puzzles and return solved and partially
## solved puzzles as strings. Most definitions are straight out of Peter Norvig's
## method, with unnessecary utilities removed. Added method to convert dict to
## string, since he uses a dict to store and print values. String makes it easier
## to interface to pygame display. Removed his main program calls, left two grids
## and unit test untouched  to save time on checking initialization and testing
## cases. A few changes still need to be made, most notably to parse_grid() to
## return the next logical conclusion, and how it arrived at that value.

global solvedCells ## Everytime assign is called, the value assigned is stored
## in this. Waaaay more time efficient than anything else I've tried so far,
## despite running through multiple duplicate entries. Considering writing
## script to remove duplicates, but without a very effiecient method/predefined
## function that might end up taking more time than running through it.
## (O(n) v O(n^2))
solvedCells = [] # Needs to be cleared everytime a new puzzle is loaded.

def cross(A, B):
    "Cross product of elements in A and elements in B."
    return [a+b for a in A for b in B]

digits   = '123456789'
rows     = 'ABCDEFGHI'
cols     = digits
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')])
units = dict((s, [u for u in unitlist if s in u])
             for s in squares)
peers = dict((s, set(sum(units[s],[]))-set([s]))
             for s in squares)

def parse_grid(grid):
    """Convert grid to a dict of possible values, {square: digits}, or
    return False if a contradiction is detected."""
    values = dict((s, digits) for s in squares)
    for s,d in grid_values(grid).items():
        if d in digits and not assign(values, s, d):
            return False ## (Fail if we can't assign d to square s.)
    return values

def grid_values(grid):
    "Convert grid into a dict of {square: char} with '0' or '.' or ' ' for empties."
    chars = [c for c in grid if c in digits or c in '0. ']
    assert len(chars) == 81
    return dict(zip(squares, chars))

def decodeDict(values):
    """Converts the dicts generated by the other functions into an 81 character
    string. Only returns string values of len() == 1, otherwise returns whitespace."""
## Bit of fortune here, but this is absolutely brilliant. Anything that needs to
## be pushed to the surface will necessarily use this to create a string. Did
## not consider this during conception, but the initial Grid states for each
## puzzle are stored in EXACTLY THE SAME FORMAT. Negates the need to constantly
## read information from the screen (Which, in any case, might not be possible),
## just modify and return the string element. If this works (No reason why it
## shouldn't), this will simplify a large portion of Week 4's work.
    a = ''
    for r in rows:
        for c in cols:
            if len(values[r+c]) == 1:
                a = a + values[r+c]
            else:
                a = a + " "
    return a

def assign(values, s, d):
    """Eliminate all the other values (except d) from values[s] and propagate.
    Return values, except return False if a contradiction is detected."""
    other_values = values[s].replace(d, '')
    if all(eliminate(values, s, d2) for d2 in other_values):
        solvedCells.append([s, d])
        return values
    else:
        return False

def eliminate(values, s, d):
    """Eliminate d from values[s]; propagate when values or places <= 2.
    Return values, except return False if a contradiction is detected."""
    if d not in values[s]:
        return values ## Already eliminated
    values[s] = values[s].replace(d,'')
    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.
    if len(values[s]) == 0:
        return False ## Contradiction: removed last value
    elif len(values[s]) == 1:
        d2 = values[s]
        if not all(eliminate(values, s2, d2) for s2 in peers[s]):
            return False
    ## (2) If a unit u is reduced to only one place for a value d, then put it there.
    for u in units[s]:
        dplaces = [s for s in u if d in values[s]]
        if len(dplaces) == 0:
            return False ## Contradiction: no place for this value
        elif len(dplaces) == 1:
            # d can only be in one place in unit; assign it there
            if not assign(values, dplaces[0], d):
                return False
    return values

## This is unnecessary in the final application
def display(values):
    "Display these values as a 2-D grid."
    width = 1+max(len(values[s]) for s in squares)
    line = '+'.join(['-'*(width*3)]*3)
    for r in rows:
        print ''.join(values[r+c].center(width)+('|' if c in '36' else '')
                      for c in cols)
        if r in 'CF': print line
    print

def solve(grid): return search(parse_grid(grid))

def search(values):
    "Using depth-first search and propagation, try all possible values."
    if values is False:
        return False ## Failed earlier
    if all(len(values[s]) == 1 for s in squares):
        return values ## Solved!
    ## Chose the unfilled square s with the fewest possibilities
    n,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
    return some(search(assign(values.copy(), s, d))
                for d in values[s])

def some(seq):
    "Return some element of seq that is true."
    for e in seq:
        if e: return e
    return False

def square2Cell(squar):
    '''Takes a cell's designation (eg: A1, E5, I9) (string), returns cell number
    (eg: 0, 40, 80) (int).'''
    if squar[0] == "A": cell = -1
    elif squar[0] == "B": cell = 8
    elif squar[0] == "C": cell = 17
    elif squar[0] == "D": cell = 26
    elif squar[0] == "E": cell = 35    
    elif squar[0] == "F": cell = 44
    elif squar[0] == "G": cell = 53
    elif squar[0] == "H": cell = 62
    elif squar[0] == "I": cell = 71
    return cell + int(squar[1])

def isSolved(stringGrid):
    "Checks if string representation of puzzle is complete."
    for i in range(0, len(stringGrid)):
        if stringGrid[i] == ' ':
            return False
    return True

def genSol(stringGrid):
    "Accepts a string grid and generates an evolving partial solution."
    b = solve(stringGrid)
    del solvedCells[:]
    a = parse_grid(stringGrid)
    display(b)
    sa = list(decodeDict(a))
    sb = list(decodeDict(b))
    print stringGrid
    print "".join(sb)
    print
    print "".join(sa)
 
    while not(isSolved("".join(sa))):
        i = 0
        while i < 81:
            if sa[i] != sb[i]:
                sa[i] = sb[i] ## Append to solvedCells? Check first
                break
            i = i + 1
        print "".join(sa)
        sa = list(decodeDict(parse_grid("".join(sa))))
        print "".join(sa)
    return b
        

#----------------------------------Solve Methods-------------------------------#
#-------------------------------------Buttons!---------------------------------#

def writeButtons(mouse):
    "Reads button values 1 through 9 from the button grid."
    if mouse[0] in range(heightBuffer + 3 * cellSize, heightBuffer + 6 * cellSize) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 13 * cellSize):
        if mouse[0] in range(heightBuffer + 3 * cellSize, heightBuffer + 4 * cellSize) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 11 * cellSize):
            writeValue = "1"
        if mouse[0] in range(heightBuffer + 4 * cellSize, heightBuffer + 5 * cellSize) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 11 * cellSize):
            writeValue = "2"
        if mouse[0] in range(heightBuffer + 5 * cellSize, heightBuffer + 6 * cellSize) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 11 * cellSize):
            writeValue = "3"
        if mouse[0] in range(heightBuffer + 3 * cellSize, heightBuffer + 4 * cellSize) and mouse[1] in range(widthBuffer + 11 * cellSize, widthBuffer + 12 * cellSize):
            writeValue = "4"
        if mouse[0] in range(heightBuffer + 4 * cellSize, heightBuffer + 5 * cellSize) and mouse[1] in range(widthBuffer + 11 * cellSize, widthBuffer + 12 * cellSize):
            writeValue = "5"
        if mouse[0] in range(heightBuffer + 5 * cellSize, heightBuffer + 6 * cellSize) and mouse[1] in range(widthBuffer + 11 * cellSize, widthBuffer + 12 * cellSize):
            writeValue = "6"
        if mouse[0] in range(heightBuffer + 3 * cellSize, heightBuffer + 4 * cellSize) and mouse[1] in range(widthBuffer + 12 * cellSize, widthBuffer + 13 * cellSize):
            writeValue = "7"
        if mouse[0] in range(heightBuffer + 4 * cellSize, heightBuffer + 5 * cellSize) and mouse[1] in range(widthBuffer + 12 * cellSize, widthBuffer + 13 * cellSize):
            writeValue = "8"
        if mouse[0] in range(heightBuffer + 5 * cellSize, heightBuffer + 6 * cellSize) and mouse[1] in range(widthBuffer + 12 * cellSize, widthBuffer + 13 * cellSize):
            writeValue = "9"
        return writeValue
    return False

def clearButton(mouse):
    "Reads the Clr value from the button grid."
    if mouse[0] in range(heightBuffer + 6 * cellSize, heightBuffer + 7 * cellSize + 1) and mouse[1] in range(widthBuffer + 12 * cellSize, widthBuffer + 13 * cellSize + 1):
        return " "
    return False

def writing(a, value, mouse):
    "Writes 'value' to the human grid."
    if mouse[0] in range(heightBuffer, heightBuffer + gridSize) and mouse[1] in range(widthBuffer, widthBuffer + gridSize):
        cellNo = (mouse[0] - heightBuffer) // cellSize + 9 * ((mouse[1] - widthBuffer) // cellSize)
        if a[cellNo] == " ":
            pygame.draw.rect(screen, (255, 255, 255), [cellHuman[cellNo][0] + 1, cellHuman[cellNo][1] + 1, 52, 52])
            font = pygame.font.Font(None, 36)
            text = font.render('%s' % value, 1, (150, 150, 150))
            textpos = text.get_rect()
            textpos.centerx = cellHuman[cellNo][0] + 27
            textpos.centery = cellHuman[cellNo][1] + 27
            screen.blit(text, textpos)
            pygame.display.update()
        print cellNo
        return True
    return False

def RESET(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer, windowWidth/2 + heightBuffer + 162) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 11 * cellSize):
        return True
    return False

def NLV(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer + 6 * cellSize, windowWidth/2 + heightBuffer + 9 * cellSize) and mouse[1] in range(widthBuffer + 10 * cellSize, widthBuffer + 11 * cellSize):
        return True
    return False

def SOLUTION(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer + 6 * cellSize, windowWidth/2 + heightBuffer + 9 * cellSize) and mouse[1] in range(widthBuffer + 13 * cellSize, widthBuffer + 14 * cellSize):
        return True
    return False

def PREVIOUSPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer, windowWidth/2 + heightBuffer + 162) and mouse[1] in range(widthBuffer + 11 * cellSize + 27, widthBuffer + 12 * cellSize + 27):
        return True
    return False

def NEXTPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer  + 6 * cellSize, windowWidth/2 + heightBuffer  + 6 * cellSize + 162) and mouse[1] in range(widthBuffer + 11 * cellSize + 27, widthBuffer + 12 * cellSize + 27):
        return True
    return False

def RANDOMPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + heightBuffer, windowWidth/2 + heightBuffer + 162) and mouse[1] in range(widthBuffer + 13 * cellSize, widthBuffer + 14 * cellSize):
        return True
    return False

def QUIT(mouse):
    if mouse[0] in range(windowWidth - 3 * cellSize, windowWidth) and mouse[1] in range(0, cellSize):
        return True
    return False
#-------------------------------------Buttons!---------------------------------#
def main():
#-----------------------------------Inits--------------------------------------#
    random.seed() ## Seeds PRNG, necessary for initialising random number generation used to load puzzles.
    pygame.init() ## Initialises Pygame module.
    global fpsLock, screen ## 'screen' is the surface that the entire interface is being rendered on. 'fpslock' is used to maintain 'fps', defined later.
    global cellHuman ## Global list runs through coordinates for each 'human' cell, i. e., cell on the left-sided grid.    
    global windowHeight, windowWidth, gridColour, background, black, gridLines, gridSize, squareSize, cellSize, widthBuffer, heightBuffer, cellHuman
    windowHeight = 1080 ## Min. height is 486, min. width is 972. No errors if dimensions are less, but the grids will overlap.
    windowWidth = 1920 ## Every positioning statement uses these values, so all prints will auto - readjust is these values are modified.
    fps = 60 ## Frames per second. Set at 60 because 60 is standard for games, this program doesn't really require it.
    gridColour = (255, 255, 255) ## RGB White
    background = (0, 255, 255) ## RGB Cyan
    black = (0, 0, 0) ## RBG...well, black
    gridLines = (200, 200, 200) ## RGB 'Light Gray'
    gridSize = int(windowHeight * 0.45) ## Dimensions of each puzzle
    squareSize = gridSize / 3 ## Dimensions of each 3x3 square (162x162)
    cellSize = squareSize / 3 ## Dimensions of each individual cell (54x54)
    widthBuffer = (windowWidth / 2 - gridSize ) / 2 ## Buffer between the grids, left window margin, right window margin, and dividing line.
    heightBuffer = (windowHeight - gridSize) / 2 ## Buffer between grids, top window margin, and bottom window margin.
    cellHuman = [[heightBuffer, widthBuffer]] ## Initialising coordinate list to the top left corner of the top left cell of the left-sided grid.

## Loop runs through top left corner of each cell of the left-sided grid, stores the coordinates as a two dimensional list in 'cellHuman'.
    i = 1
    while i < 81:
        if i % 9 == 0:            
            cellHuman.append([heightBuffer, cellHuman[len(cellHuman) -1][1] + 54])
        else:
            cellHuman.append([cellHuman[len(cellHuman) -1][0] + 54, cellHuman[len(cellHuman) -1][1]])
        i = i + 1

        
    screen = pygame.display.set_mode((windowWidth, windowHeight))#, FULLSCREEN) ## Defines the size of the surface generated, remove the # infront of FULLSCREEN to make it, uhh, go fullscreen.
## If you get a syntax error when trying to run FULLSCREEN, count the number of brackets in the statement.
    fpsLock = pygame.time.Clock() ## Initializing the lock on fps, called during run-time event loop to tick 'fps' times per second.
    pygame.display.set_caption("Sudoku Solver") ## Window caption, unimportant if running in FULLSCREEN.
    screen.fill(background) ## Fills the entire surface with colour
## Draws rectangle where our sudoku puzzles will go, to give them a different background.
    pygame.draw.rect(screen, gridColour, [heightBuffer, widthBuffer, gridSize, gridSize]) 
    pygame.draw.rect(screen, gridColour, [windowWidth/2 + heightBuffer, widthBuffer, gridSize, gridSize])
#-----------------------------------Inits--------------------------------------#
#---------------------------------Draw Methods---------------------------------#
    def drawGrid():
        "Draws two 486x486 resolution, 9x9 cell grids, as well as a dividing line in the centre of the surface. The grids are each centred in their respective half of the surface."
## Loops for drawing the inner 'Light Gray' lines. Lines for the border are also drawn, but later overdrawn by black lines.
        for x in range(heightBuffer , heightBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (x, widthBuffer), (x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (heightBuffer, y), (gridSize - 1 + heightBuffer, y))

        for x in range(heightBuffer , heightBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (x, widthBuffer), (x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (heightBuffer, y), (gridSize - 1 + heightBuffer, y))

## Drawing button grid
        pygame.draw.rect(screen, (0, 0, 0), [heightBuffer + 3 * cellSize, widthBuffer + 10 * cellSize, 3 * cellSize, 3 * cellSize])
        pygame.draw.rect(screen, (0, 0, 0), [heightBuffer + 6 * cellSize, widthBuffer + 12 * cellSize, cellSize, cellSize])

        for x in range(heightBuffer + 3 * cellSize, heightBuffer + 6 * cellSize + 1, cellSize):
            pygame.draw.line(screen, (255, 255, 255), (x, widthBuffer + 10 * cellSize), (x, widthBuffer + 13 * cellSize))
        for y in range(widthBuffer + 10 * cellSize, widthBuffer + 13 * cellSize + 1, cellSize):
            pygame.draw.line(screen, (255, 255, 255), (heightBuffer + 3 * cellSize, y), (heightBuffer + 6 * cellSize, y))
        pygame.draw.line(screen, (255, 255, 255), (heightBuffer + 6 * cellSize, widthBuffer + 13 * cellSize), (heightBuffer + 7 * cellSize, widthBuffer + 13 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (heightBuffer + 6 * cellSize, widthBuffer + 12 * cellSize), (heightBuffer + 7 * cellSize, widthBuffer + 12 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (heightBuffer + 7 * cellSize, widthBuffer + 12 * cellSize), (heightBuffer + 7 * cellSize, widthBuffer + 13 * cellSize))

        font = pygame.font.Font(None, 36)
        text = font.render("Clr", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = heightBuffer + 6 * cellSize + 27
        textpos.centery = widthBuffer + 12 * cellSize + 27
        screen.blit(text, textpos)
        i = 1
        for y in range(widthBuffer + 10 * cellSize + 27, widthBuffer + 13 * cellSize, cellSize):
            for x in range(heightBuffer + 3 * cellSize + 27, heightBuffer + 6 * cellSize, cellSize):            
                text = font.render('%s' % i, 1, (255, 255, 255))
                textpos = text.get_rect()
                textpos.centerx = x
                textpos.centery = y
                screen.blit(text, textpos)
                i = i + 1

## Quit
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth - 3 * cellSize, 0, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, 0), (windowWidth,0))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, cellSize), (windowWidth, cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, 0), (windowWidth - 3 * cellSize, cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 1, 0), (windowWidth - 1, cellSize))
        text = font.render("Exit", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth - 2 * cellSize + 27
        textpos.centery = 27
        screen.blit(text, textpos)
        
## Reset Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer, widthBuffer + 10 * cellSize, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 10 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 11 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer, widthBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 11 * cellSize))
        text = font.render("Reset", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + cellSize + 27
        textpos.centery = widthBuffer + 10 * cellSize + 27
        screen.blit(text, textpos)

## NLV Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 10 * cellSize, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 10 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 11 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 10 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 11 * cellSize))
        text = font.render("NLV", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + 7 * cellSize + 27
        textpos.centery = widthBuffer + 10 * cellSize + 27
        screen.blit(text, textpos)

## Solution Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 13 * cellSize, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 13 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 14 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer + 6 * cellSize, widthBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 14 * cellSize))
        text = font.render("Solution", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + 7 * cellSize + 27
        textpos.centery = widthBuffer + 13 * cellSize + 27
        screen.blit(text, textpos)

## Next Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer  + 6 * cellSize, widthBuffer + 11 * cellSize + 27, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer  + 6 * cellSize, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 11 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer  + 6 * cellSize, widthBuffer + 12 * cellSize + 27), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 12 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer  + 6 * cellSize, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer  + 6 * cellSize, widthBuffer + 12 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer + 9 * cellSize, widthBuffer + 12 * cellSize + 27))
        text = font.render("Next", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + 7 * cellSize + 27
        textpos.centery = widthBuffer + 12 * cellSize
        screen.blit(text, textpos)

## Previous Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer, widthBuffer + 11 * cellSize + 27, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 11 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 12 * cellSize + 27), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 12 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer, widthBuffer + 12 * cellSize + 27))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 11 * cellSize + 27), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 12 * cellSize + 27))
        text = font.render("Previous", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + cellSize + 27
        textpos.centery = widthBuffer + 12 * cellSize
        screen.blit(text, textpos)

## Random Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + heightBuffer, widthBuffer + 13 * cellSize, 162, 54])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 13 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 14 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer, widthBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 13 * cellSize), (windowWidth/2 + heightBuffer + 3 * cellSize, widthBuffer + 14 * cellSize))
        text = font.render("Random", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + heightBuffer + cellSize + 27
        textpos.centery = widthBuffer + 14 * cellSize - 27
        screen.blit(text, textpos)
        
        
## Dividing line in the middle of the screen.
        pygame.draw.line(screen, black, (windowWidth/ 2, 5), (windowWidth/2, windowHeight - 5)) 
        
## Loops for drawing grid and 3x3 square outlines in black.
        for x in range(heightBuffer , heightBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + x, widthBuffer), (windowWidth/2 + x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + heightBuffer, y), (windowWidth/2 + gridSize - 1 + heightBuffer, y))
        for x in range(heightBuffer , heightBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (windowWidth/2 + x, widthBuffer), (windowWidth/2 + x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (windowWidth/2 + heightBuffer, y), (windowWidth/2 + gridSize - 1 + heightBuffer, y))
        return None

    def initGridLeft(a):
        "Initialises left-sided grid with values from a, which should be an 81 character string."
## No need to check if len(a) == 81, since functions in SudoModule take care of that.
        i = 0
        font = pygame.font.Font(None, 36) ## Defines text font and size, None is Pygame default.
        while i < 81:
            text = font.render('%s' % a[i], 1, (0, 0, 0)) ## String in a[i] (In this case, it is a single character) is stored in text. Other attributes are anti-aliasing (1 -> On, 0 -> Off) and colour ((0, 0, 0) is RGB Black).
            textpos = text.get_rect()
## The next bit aligns the x, y centres of the text to the centre of the grid, then blits it onto the surface. 
            textpos.centerx = cellHuman[i][0] + 27 
            textpos.centery = cellHuman[i][1] + 27
            screen.blit(text, textpos)
            i = i + 1

    def initGridRight(a, colour = (0, 0, 0)):
        "Initialises right-sided grid with values from a, which should be an 81 character string."
        i = 0
        font = pygame.font.Font(None, 36)
        while i < 81:
            text = font.render('%s' % a[i], 1, colour)
            textpos = text.get_rect()
            textpos.centerx = cellHuman[i][0] + windowWidth / 2 + 27
            textpos.centery = cellHuman[i][1] + 27
            screen.blit(text, textpos)
            i = i + 1

    def emptyGrid(a):
        "Empties grid a (0 for left grid, 1 for right grid)."
        pygame.draw.rect(screen, gridColour, [a * windowWidth/2 + heightBuffer, widthBuffer, gridSize, gridSize])
        drawGrid()

    def initCellLeft(a, i):
        "Loads a single cell entry a, into cell i on the left-sided grid."
        font = pygame.font.Font(None, 36)
        text = font.render('%s' % a, 1, (0, 0, 0))
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + 27
        textpos.centery = cellHuman[i][1] + 27
        screen.blit(text, textpos)

    def initCellRight(a, i, colour = (0, 0, 0)):
        "Loads a single cell entry a, into cell i on the right-sided grid."
        font = pygame.font.Font(None, 36)
        text = font.render('%s' % a, 1, colour)
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + windowWidth / 2 + 27
        textpos.centery = cellHuman[i][1] + 27
        screen.blit(text, textpos)      
        
#---------------------------------Draw Methods---------------------------------#

## Execution starts here.    
    drawGrid() ## Sets up both grids and dividing line.
    grid = []
    f = open('Puzzles.txt', 'r')
    for line in f:
        grid.append(line)
    f.close()
    grid.append('  3 2 6  9  3 5  1  18 64    81 29  7       8  67 82    26 95  8  2 3  9  5 1 3  ')
    grid.append('4     8 5 3          7      2     6     8 4      1       6 3 7 5  2     1 4      ') 
    grid.append('8          36      7  9 2   5   7       457     1   3   1    68  85   1  9    4  ') ## 'Hardest sudoku', atleast as of 2012.
    grid.append('    9  8 7    54 3 3671 2  85 4379             7986 35  5 4139 1 35    4 8  6    ')
    puzzleNo = random.randrange(0, len(grid))    
    print solvedCells
    del solvedCells[:]
    a = grid[puzzleNo]
##    b = solve(a)
##    display(b)
##    print isSolved(decodeDict(b))
    b = genSol(a)
    initGridLeft(a)
    initGridRight(a)
    pygame.display.update()
    value = " "
####    print solvedCells
####    pygame.time.delay(2000)
##    initGridRight(a)
##    pygame.display.update()
####    pygame.time.delay(500)
##    i = 0
##    while i < len(solvedCells):
##        if a[square2Cell(solvedCells[i][0])] == " ":
##            initCellRight(solvedCells[i][1], square2Cell(solvedCells[i][0]), (150, 150, 150))
##            pygame.display.update() 
##            pygame.time.delay(100) ## In the final module, instead of delay this
#### is either controlled by button input, or user input in to grid0 (left grid).
##        i = i + 1
    
## Event loop, keeps the everything as is until QUIT button is hit.
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == MOUSEBUTTONDOWN:
                if writeButtons(pygame.mouse.get_pos()):
                    value = writeButtons(pygame.mouse.get_pos())
                    print
                    print value
                elif clearButton(pygame.mouse.get_pos()):
                    print
                    value = clearButton(pygame.mouse.get_pos())
                    print "Clear!"
                elif writing(a, value, pygame.mouse.get_pos()):
                    print value
                elif RESET(pygame.mouse.get_pos()):
                    print
                    print "Reset!"
                    emptyGrid(0)
                    initGridLeft(a)
                    pygame.display.update()
                elif SOLUTION(pygame.mouse.get_pos()):
                    print
                    print "Solution!"
                    initGridRight(decodeDict(b), (150, 150, 150))
                    initGridRight(a)
                    pygame.display.update()
                elif PREVIOUSPUZZLE(pygame.mouse.get_pos()):
                    print
                    print "Old Puzzle!" 
                    del solvedCells[:]
                    emptyGrid(0) 
                    emptyGrid(1)
                    if puzzleNo == 0:
                        puzzleNo = len(grid) - 1
                    else:
                        puzzleNo = puzzleNo - 1
                    a = grid[puzzleNo]
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                elif NEXTPUZZLE(pygame.mouse.get_pos()):
                    print
                    print "New Puzzle!" 
                    del solvedCells[:]
                    emptyGrid(0)
                    emptyGrid(1)
                    if puzzleNo == len(grid) - 1:
                        puzzleNo = 0
                    else:
                        puzzleNo = puzzleNo + 1
                    a = grid[puzzleNo]
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                elif RANDOMPUZZLE(pygame.mouse.get_pos()):
                    print
                    print "Random!" 
                    del solvedCells[:]
                    emptyGrid(0)
                    emptyGrid(1)
                    puzzleNo = random.randrange(0, len(grid))
                    a = grid[puzzleNo]
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                elif QUIT(pygame.mouse.get_pos()):
                    print
                    print "Quitting!"
                    pygame.quit()
                    sys.exit()
                elif NLV(pygame.mouse.get_pos()):
                    print
                    print "Soon..."
            elif event.type == MOUSEBUTTONUP:
                emptyGrid(1)
                initGridRight(a)
        pygame.display.update()
        fpsLock.tick(fps) ## Refreshes the screen 'fps' times per second.

if __name__ == '__main__':
    main() 
