#--------------------------------Imports---------------------------------------#
import pygame, sys
from pygame.locals import *
import random
#--------------------------------Imports---------------------------------------#
#----------------------------------Solve Methods-------------------------------#
## These are the functions to solve puzzles and return solved and partially
## solved puzzles as strings. Most definitions are straight out of Peter Norvig's
## method, with unnessecary utilities removed. Added method to convert dict to
## string, since he uses a dict to store and print values. String makes it easier
## to interface to pygame display. Removed his main program calls, left two grids
## and unit test untouched  to save time on checking initialization and testing
## cases. A few changes still need to be made, most notably to parse_grid() to
## return the next logical conclusion, and how it arrived at that value.

global solvedCells ## Everytime assign is called, the value assigned is stored
## in this. Waaaay more time efficient than anything else I've tried so far,
## despite running through multiple duplicate entries. Considering writing
## script to remove duplicates, but without a very effiecient method/predefined
## function that might end up taking more time than running through it.
## (O(n) v O(n^2))
global playerSolution
playerSolution = []
solvedCells = [] # Needs to be cleared everytime a new puzzle is loaded.
for i in range(0, 81):
    playerSolution.append(' ')

def cross(A, B):
    "Cross product of elements in A and elements in B."
    return [a+b for a in A for b in B]

digits   = '123456789'
rows     = 'ABCDEFGHI'
cols     = digits
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')])
units = dict((s, [u for u in unitlist if s in u])
             for s in squares)
peers = dict((s, set(sum(units[s],[]))-set([s]))
             for s in squares)

def parse_grid(grid):
    """Convert grid to a dict of possible values, {square: digits}, or
    return False if a contradiction is detected."""
    values = dict((s, digits) for s in squares)
    i = 0
    for s,d in grid_values(grid).items():
        j = i
        if d in digits and not assign(values, s, d, i):
            return False ## (Fail if we can't assign d to square s.)
        solvedCells[j:i] = solvedCells[j:i][::-1]        
    return values

def grid_values(grid):
    "Convert grid into a dict of {square: char} with '0' or '.' or ' ' for empties."
    chars = [c for c in grid if c in digits or c in '0. ']
    assert len(chars) == 81
    return dict(zip(squares, chars))

def decodeDict(values):
    """Converts the dicts generated by the other functions into an 81 character
    string. Only returns string values of len() == 1, otherwise returns whitespace."""
## Bit of fortune here, but this is absolutely brilliant. Anything that needs to
## be pushed to the surface will necessarily use this to create a string. Did
## not consider this during conception, but the initial Grid states for each
## puzzle are stored in EXACTLY THE SAME FORMAT. Negates the need to constantly
## read information from the screen (Which, in any case, might not be possible),
## just modify and return the string element. If this works (No reason why it
## shouldn't), this will simplify a large portion of Week 4's work.
    a = ''
    for r in rows:
        for c in cols:
            if len(values[r+c]) == 1:
                a = a + values[r+c]
            else:
                a = a + " "
    return a

def assign(values, s, d, i):
    """Eliminate all the other values (except d) from values[s] and propagate.
    Return values, except return False if a contradiction is detected."""
    peerList = []
    other_values = values[s].replace(d, '')
    if all(eliminate(values, s, d2) for d2 in other_values):
        if [s, d, 0] not in solvedCells and [s, d, 1] not in solvedCells and [s, d, 2] not in solvedCells:
            peerList.append(d)
            for s2 in peers[s]:
                if len(values[s2]) == 1 and values[s2] not in peerList:
                    peerList.append(values[s2])            
            peerList.sort()
            if ''.join(peerList) == "123456789":
                solvedCells.append([s, d, 2])
                i = i + 1
            else:
                solvedCells.append([s, d, 0])
                i = i + 1
        return values
    else:
        return False

def eliminate(values, s, d):
    """Eliminate d from values[s]; propagate when values or places <= 2.
    Return values, except return False if a contradiction is detected."""
    if d not in values[s]:
        return values ## Already eliminated
    values[s] = values[s].replace(d,'')
    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.
    if len(values[s]) == 0:
        return False ## Contradiction: removed last value
    elif len(values[s]) == 1:
        d2 = values[s]
        if not all(eliminate(values, s2, d2) for s2 in peers[s]):
            return False
    ## (2) If a unit u is reduced to only one place for a value d, then put it there.
    for u in units[s]:
        dplaces = [s for s in u if d in values[s]]
        if len(dplaces) == 0:
            return False ## Contradiction: no place for this value
        elif len(dplaces) == 1:
            # d can only be in one place in unit; assign it there
            if not assign(values, dplaces[0], d):
                return False
    return values

## This is unnecessary in the final application
def display(values):
    "Display these values as a 2-D grid."
    width = 1+max(len(values[s]) for s in squares)
    line = '+'.join(['-'*(width*3)]*3)
    for r in rows:
        print ''.join(values[r+c].center(width)+('|' if c in '36' else '')
                      for c in cols)
        if r in 'CF': print line
    print

def solve(grid): return search(parse_grid(grid))

def search(values):
    "Using depth-first search and propagation, try all possible values."
    if values is False:
        return False ## Failed earlier
    if all(len(values[s]) == 1 for s in squares):
        return values ## Solved!
    ## Chose the unfilled square s with the fewest possibilities
    n,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
    return some(search(assign(values.copy(), s, d))
                for d in values[s])

def some(seq):
    "Return some element of seq that is true."
    for e in seq:
        if e: return e
    return False

def square2Cell(squar):
    '''Takes a cell's designation (eg: A1, E5, I9) (string), returns cell number
    (eg: 0, 40, 80) (int).'''
    if squar[0] == "A": cell = -1
    elif squar[0] == "B": cell = 8
    elif squar[0] == "C": cell = 17
    elif squar[0] == "D": cell = 26
    elif squar[0] == "E": cell = 35    
    elif squar[0] == "F": cell = 44
    elif squar[0] == "G": cell = 53
    elif squar[0] == "H": cell = 62
    elif squar[0] == "I": cell = 71
    return cell + int(squar[1])

def isSolved(stringGrid):
    "Checks if string representation of puzzle is complete."
    for i in range(0, len(stringGrid)):
        if stringGrid[i] == ' ':
            return False
    return True

def Coord(cellNo):
    "Takes a cell number, returns cell designation."
    a = "ABCDEFGHI"
    return a[cellNo/9] + str(cellNo % 9 + 1)

def genSol(stringGrid):
    "Accepts a string grid and generates an evolving partial solution."
    b = solve(stringGrid)
    del solvedCells[:]
    a = parse_grid(stringGrid)
##    display(b)
    sa = list(decodeDict(a))
    sb = list(decodeDict(b))
    print stringGrid
    print "".join(sb)
    print
    print "".join(sa)
 
    while not(isSolved("".join(sa))):
        i = 0
        while i < 81:
            if sa[i] != sb[i]:
                sa[i] = sb[i]
                if [Coord(i), sb[i], 0] not in solvedCells and [Coord(i), sb[i], 1] not in solvedCells and [Coord(i), sb[i], 2] not in solvedCells:
                    solvedCells.append([Coord(i), sb[i], 1])
                ## Append to solvedCells? Check first
                break
            i = i + 1
        print "".join(sa)
        sa = list(decodeDict(parse_grid("".join(sa))))
        print "".join(sa)
    return b 

#----------------------------------Solve Methods-------------------------------#
#-------------------------------------Buttons!---------------------------------#

def writeButtons(mouse):
    "Reads button values 1 through 9 from the button grid."
    if mouse[0] in range(widthBuffer + 3 * cellSize, widthBuffer + 6 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 13 * cellSize):
        if mouse[0] in range(widthBuffer + 3 * cellSize, widthBuffer + 4 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 11 * cellSize):
            writeValue = "1"
        if mouse[0] in range(widthBuffer + 4 * cellSize, widthBuffer + 5 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 11 * cellSize):
            writeValue = "2"
        if mouse[0] in range(widthBuffer + 5 * cellSize, widthBuffer + 6 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 11 * cellSize):
            writeValue = "3"
        if mouse[0] in range(widthBuffer + 3 * cellSize, widthBuffer + 4 * cellSize) and mouse[1] in range(heightBuffer + 11 * cellSize, heightBuffer + 12 * cellSize):
            writeValue = "4"
        if mouse[0] in range(widthBuffer + 4 * cellSize, widthBuffer + 5 * cellSize) and mouse[1] in range(heightBuffer + 11 * cellSize, heightBuffer + 12 * cellSize):
            writeValue = "5"
        if mouse[0] in range(widthBuffer + 5 * cellSize, widthBuffer + 6 * cellSize) and mouse[1] in range(heightBuffer + 11 * cellSize, heightBuffer + 12 * cellSize):
            writeValue = "6"
        if mouse[0] in range(widthBuffer + 3 * cellSize, widthBuffer + 4 * cellSize) and mouse[1] in range(heightBuffer + 12 * cellSize, heightBuffer + 13 * cellSize):
            writeValue = "7"
        if mouse[0] in range(widthBuffer + 4 * cellSize, widthBuffer + 5 * cellSize) and mouse[1] in range(heightBuffer + 12 * cellSize, heightBuffer + 13 * cellSize):
            writeValue = "8"
        if mouse[0] in range(widthBuffer + 5 * cellSize, widthBuffer + 6 * cellSize) and mouse[1] in range(heightBuffer + 12 * cellSize, heightBuffer + 13 * cellSize):
            writeValue = "9"
        return writeValue
    return False

def clearButton(mouse):
    "Reads the Clr value from the button grid."
    if mouse[0] in range(widthBuffer + 6 * cellSize, widthBuffer + 7 * cellSize + 1) and mouse[1] in range(heightBuffer + 12 * cellSize, heightBuffer + 13 * cellSize + 1):
        return " "
    return False

def writing(a, playerSolution, value, mouse):
    "Writes 'value' to the human grid."
    if mouse[0] in range(widthBuffer, widthBuffer + 9 * cellSize) and mouse[1] in range(heightBuffer, heightBuffer + 9 * cellSize):
        cellNo = (mouse[0] - widthBuffer) // cellSize + 9 * ((mouse[1] - heightBuffer) // cellSize)
##        print cellNo, playerSolution[cellNo]
##        print playerSolution
        playerSolution[cellNo] = value
        if a[cellNo] == " ":
            pygame.draw.rect(screen, (255, 255, 255), [cellHuman[cellNo][0] + 1, cellHuman[cellNo][1] + 1, cellSize-2, cellSize-2])
            font = pygame.font.Font(None, int(windowWidth * 0.01875))
            text = font.render('%s' % value, 1, (150, 150, 150))
            textpos = text.get_rect()
            textpos.centerx = cellHuman[cellNo][0] + cellSize/2
            textpos.centery = cellHuman[cellNo][1] + cellSize/2
            screen.blit(text, textpos)
            pygame.display.update()
        print Coord(cellNo)
        return True
    return False

def RESET(mouse):
    if mouse[0] in range(windowWidth/2 + widthBuffer, windowWidth/2 + widthBuffer + 3 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 11 * cellSize):
        return True
    return False

def NLV(mouse):
    if mouse[0] in range(windowWidth/2 + widthBuffer + 6 * cellSize, windowWidth/2 + widthBuffer + 9 * cellSize) and mouse[1] in range(heightBuffer + 10 * cellSize, heightBuffer + 11 * cellSize):
        return True
    return False

##def SOLUTION(mouse):
##    if mouse[0] in range(windowWidth/2 +widthBuffer + 6 * cellSize, windowWidth/2 + widthBuffer + 9 * cellSize) and mouse[1] in range(heightBuffer + 13 * cellSize, heightBuffer + 14 * cellSize):
##        return True
##    return False

def PREVIOUSPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + widthBuffer, windowWidth/2 + widthBuffer + 3 * cellSize) and mouse[1] in range(heightBuffer + 11 * cellSize + cellSize/2, heightBuffer + 12 * cellSize + cellSize/2):
        return True
    return False

def NEXTPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + widthBuffer  + 6 * cellSize, windowWidth/2 + widthBuffer  + 6 * cellSize + 3 * cellSize) and mouse[1] in range(heightBuffer + 11 * cellSize + cellSize/2, heightBuffer + 12 * cellSize + cellSize/2):
        return True
    return False

def RANDOMPUZZLE(mouse):
    if mouse[0] in range(windowWidth/2 + widthBuffer, windowWidth/2 + widthBuffer + 3 * cellSize) and mouse[1] in range(heightBuffer + 13 * cellSize, heightBuffer + 14 * cellSize):
        return True
    return False

def QUIT(mouse):
    if mouse[0] in range(windowWidth - 3 * cellSize, windowWidth) and mouse[1] in range(0, cellSize):
        return True
    return False
#-------------------------------------Buttons!---------------------------------#
def main():
#-----------------------------------Inits--------------------------------------#
    random.seed() ## Seeds PRNG, necessary for initialising random number generation used to load puzzles.
    pygame.init() ## Initialises Pygame module.
    global fpsLock, screen ## 'screen' is the surface that the entire interface is being rendered on. 'fpslock' is used to maintain 'fps', defined later.
    global cellHuman ## Global list runs through coordinates for each 'human' cell, i. e., cell on the left-sided grid.    
    global windowHeight, windowWidth, gridColour, background, black, gridLines, gridSize, squareSize, cellSize, widthBuffer, heightBuffer, cellHuman
    windowHeight = 768 ## Min. height is 486, min. width is 972. No errors if dimensions are less, but the grids will overlap.
    windowWidth = 1366 ## Every positioning statement uses these values, so all prints will auto - readjust is these values are modified.
    fps = 60 ## Frames per second. Set at 60 because 60 is standard for games, this program doesn't really require it.
    gridColour = (255, 255, 255) ## RGB White
    background = (0, 255, 255) ## RGB Cyan
    black = (0, 0, 0) ## RBG...well, black
    gridLines = (200, 200, 200) ## RGB 'Light Gray'
    cellSize = (int(windowHeight * 0.45)/3)/3 ## Dimensions of each puzzle
##    squareSize = gridSize / 3 ## Dimensions of each 3x3 square (162x162)
##    cellSize = squareSize / 3 ## Dimensions of each individual cell (54x54)
    widthBuffer = (windowWidth / 2 - 9 * cellSize ) / 2 ## Buffer between the grids, left window margin, right window margin, and dividing line.
    heightBuffer = (windowHeight - 9 * cellSize) / 2 ## Buffer between grids, top window margin, and bottom window margin.
    cellHuman = [[widthBuffer, heightBuffer]] ## Initialising coordinate list to the top left corner of the top left cell of the left-sided grid.

## Loop runs through top left corner of each cell of the left-sided grid, stores the coordinates as a two dimensional list in 'cellHuman'.
    i = 1
    while i < 81:
        if i % 9 == 0:            
            cellHuman.append([widthBuffer, cellHuman[len(cellHuman) -1][1] + cellSize])
        else:
            cellHuman.append([cellHuman[len(cellHuman) -1][0] + cellSize, cellHuman[len(cellHuman) -1][1]])
        i = i + 1

        
    screen = pygame.display.set_mode((windowWidth, windowHeight))#, FULLSCREEN) ## Defines the size of the surface generated, remove the # infront of FULLSCREEN to make it, uhh, go fullscreen.
## If you get a syntax error when trying to run FULLSCREEN, count the number of brackets in the statement.
    fpsLock = pygame.time.Clock() ## Initializing the lock on fps, called during run-time event loop to tick 'fps' times per second.
    pygame.display.set_caption("Sudoku Solver") ## Window caption, unimportant if running in FULLSCREEN.
    screen.fill(background) ## Fills the entire surface with colour
## Draws rectangle where our sudoku puzzles will go, to give them a different background.
    pygame.draw.rect(screen, gridColour, [widthBuffer, heightBuffer, 9 * cellSize, 9 * cellSize]) 
    pygame.draw.rect(screen, gridColour, [windowWidth/2 + widthBuffer, heightBuffer, 9 * cellSize, 9 * cellSize])
#-----------------------------------Inits--------------------------------------#
#---------------------------------Draw Methods---------------------------------#
    def drawGrid():
        "Draws two 486x486 resolution, 9x9 cell grids, as well as a dividing line in the centre of the surface. The grids are each centred in their respective half of the surface."
## Loops for drawing the inner 'Light Gray' lines. Lines for the border are also drawn, but later overdrawn by black lines.
        for x in range(widthBuffer , widthBuffer + 9 * cellSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (x, heightBuffer), (x, 9 * cellSize - 1 + heightBuffer))
        for y in range(heightBuffer, heightBuffer + 9 * cellSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (widthBuffer, y), (9 * cellSize - 1 + widthBuffer, y))

        for x in range(widthBuffer , widthBuffer + 9 * cellSize + 1, 3 * cellSize):
            pygame.draw.line(screen, black, (x, heightBuffer), (x, 9 * cellSize - 1 + heightBuffer))
        for y in range(heightBuffer, heightBuffer + 9 * cellSize + 1, 3 * cellSize):
            pygame.draw.line(screen, black, (widthBuffer, y), (9 * cellSize - 1 + widthBuffer, y))

## Drawing button grid
        pygame.draw.rect(screen, (0, 0, 0), [widthBuffer + 3 * cellSize, heightBuffer + 10 * cellSize, 3 * cellSize, 3 * cellSize])
        pygame.draw.rect(screen, (0, 0, 0), [widthBuffer + 6 * cellSize, heightBuffer + 12 * cellSize, cellSize, cellSize])

        for x in range(widthBuffer + 3 * cellSize, widthBuffer + 6 * cellSize + 1, cellSize):
            pygame.draw.line(screen, (255, 255, 255), (x, heightBuffer + 10 * cellSize), (x, heightBuffer + 13 * cellSize))
        for y in range(heightBuffer + 10 * cellSize, heightBuffer + 13 * cellSize + 1, cellSize):
            pygame.draw.line(screen, (255, 255, 255), (widthBuffer + 3 * cellSize, y), (widthBuffer + 6 * cellSize, y))
        pygame.draw.line(screen, (255, 255, 255), (widthBuffer + 6 * cellSize, heightBuffer + 13 * cellSize), (widthBuffer + 7 * cellSize, heightBuffer + 13 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (widthBuffer + 6 * cellSize, heightBuffer + 12 * cellSize), (widthBuffer + 7 * cellSize, heightBuffer + 12 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (widthBuffer + 7 * cellSize, heightBuffer + 12 * cellSize), (widthBuffer + 7 * cellSize, heightBuffer + 13 * cellSize))

        font = pygame.font.Font(None, int(windowWidth * 0.01875))
        text = font.render("Clr", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = widthBuffer + 6 * cellSize + cellSize/2
        textpos.centery = heightBuffer + 12 * cellSize + cellSize/2
        screen.blit(text, textpos)
        i = 1
        for y in range(heightBuffer + 10 * cellSize + cellSize/2, heightBuffer + 13 * cellSize, cellSize):
            for x in range(widthBuffer + 3 * cellSize + cellSize/2, widthBuffer + 6 * cellSize, cellSize):            
                text = font.render('%s' % i, 1, (255, 255, 255))
                textpos = text.get_rect()
                textpos.centerx = x
                textpos.centery = y
                screen.blit(text, textpos)
                i = i + 1

## Quit
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth - 3 * cellSize, 0, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, 0), (windowWidth,0))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, cellSize), (windowWidth, cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 3 * cellSize, 0), (windowWidth - 3 * cellSize, cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth - 1, 0), (windowWidth - 1, cellSize))
        text = font.render("Exit", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth - 2 * cellSize + cellSize/2
        textpos.centery = cellSize/2
        screen.blit(text, textpos)
        
## Reset Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer, heightBuffer + 10 * cellSize, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 10 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 11 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer, heightBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 11 * cellSize))
        text = font.render("Reset", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + widthBuffer + cellSize + cellSize/2
        textpos.centery = heightBuffer + 10 * cellSize + cellSize/2
        screen.blit(text, textpos)

## NLV Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 10 * cellSize, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 10 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 11 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 11 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 10 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 11 * cellSize))
        text = font.render("Next Value", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + widthBuffer + 7 * cellSize + cellSize/2
        textpos.centery = heightBuffer + 10 * cellSize + cellSize/2
        screen.blit(text, textpos)

## Solution Button
##        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 13 * cellSize, 3 * cellSize, cellSize])
##        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 13 * cellSize))
##        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 14 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 14 * cellSize))
##        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 14 * cellSize))
##        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 14 * cellSize))
##        text = font.render("Solution", 1, (255, 255, 255))
##        textpos = text.get_rect()
##        textpos.centerx = windowWidth/2 + widthBuffer + 7 * cellSize + cellSize/2
##        textpos.centery = heightBuffer + 13 * cellSize + cellSize/2
##        screen.blit(text, textpos)

## Next Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 11 * cellSize + cellSize/2, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 11 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 12 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 12 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 6 * cellSize, heightBuffer + 12 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 9 * cellSize, heightBuffer + 12 * cellSize + cellSize/2))
        text = font.render("Next", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + widthBuffer + 7 * cellSize + cellSize/2
        textpos.centery = heightBuffer + 12 * cellSize
        screen.blit(text, textpos)

## Previous Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer, heightBuffer + 11 * cellSize + cellSize/2, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 11 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 12 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 12 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer, heightBuffer + 12 * cellSize + cellSize/2))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 11 * cellSize + cellSize/2), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 12 * cellSize + cellSize/2))
        text = font.render("Previous", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + widthBuffer + cellSize + cellSize/2
        textpos.centery = heightBuffer + 12 * cellSize
        screen.blit(text, textpos)

## Random Puzzle Button
        pygame.draw.rect(screen, (0, 0, 0), [windowWidth/2 + widthBuffer, heightBuffer + 13 * cellSize, 3 * cellSize, cellSize])
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 13 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 14 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer, heightBuffer + 14 * cellSize))
        pygame.draw.line(screen, (255, 255, 255), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 13 * cellSize), (windowWidth/2 + widthBuffer + 3 * cellSize, heightBuffer + 14 * cellSize))
        text = font.render("Random", 1, (255, 255, 255))
        textpos = text.get_rect()
        textpos.centerx = windowWidth/2 + widthBuffer + cellSize + cellSize/2
        textpos.centery = heightBuffer + 14 * cellSize - cellSize/2
        screen.blit(text, textpos)         
        
## Dividing line in the middle of the screen.
        pygame.draw.line(screen, black, (windowWidth/ 2, 5), (windowWidth/2, windowHeight - 5)) 
        
## Loops for drawing grid and 3x3 square outlines in black.
        for x in range(widthBuffer , widthBuffer + 9 * cellSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + x, heightBuffer), (windowWidth/2 + x, 9 * cellSize - 1 + heightBuffer))
        for y in range(heightBuffer, heightBuffer + 9 * cellSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + widthBuffer, y), (windowWidth/2 + 9 * cellSize - 1 + widthBuffer, y))
        for x in range(widthBuffer , widthBuffer + 9 * cellSize + 1, 3 * cellSize):
            pygame.draw.line(screen, black, (windowWidth/2 + x, heightBuffer), (windowWidth/2 + x, 9 * cellSize - 1 + heightBuffer))
        for y in range(heightBuffer, heightBuffer + 9 * cellSize + 1, 3 * cellSize):
            pygame.draw.line(screen, black, (windowWidth/2 + widthBuffer, y), (windowWidth/2 + 9 * cellSize - 1 + widthBuffer, y))
        return None

    def coorMark():
        font = pygame.font.Font(None, int(windowWidth * 0.01875))
        i = 0
        while i < 9:
            text = font.render('%s' % str(i+1), 1, (0, 0, 0))
            textpos = text.get_rect()
            textpos.centerx = windowWidth/2 + cellHuman[i][0] + cellSize/2
            textpos.centery = cellHuman[i][1] - cellSize/2
            screen.blit(text, textpos)
            i = i + 1

        i = 0
        alpha = "ABCDEFGHI"
        while i < 81:
            text = font.render('%s' % alpha[i/9], 1, (0, 0, 0))
            textpos = text.get_rect()
            textpos.centerx = windowWidth/2 + cellHuman[i][0] - cellSize/2
            textpos.centery = cellHuman[i][1] + cellSize/2
            screen.blit(text, textpos)
            i = i + 9
    
    def initGridLeft(a):
        "Initialises left-sided grid with values from a, which should be an 81 character string."
## No need to check if len(a) == 81, since functions in SudoModule take care of that.
        i = 0
        font = pygame.font.Font(None, int(windowWidth * 0.01875)) ## Defines text font and size, None is Pygame default.
        while i < 81:
            text = font.render('%s' % a[i], 1, (0, 0, 0)) ## String in a[i] (In this case, it is a single character) is stored in text. Other attributes are anti-aliasing (1 -> On, 0 -> Off) and colour ((0, 0, 0) is RGB Black).
            textpos = text.get_rect()
## The next bit aligns the x, y centres of the text to the centre of the grid, then blits it onto the surface. 
            textpos.centerx = cellHuman[i][0] + cellSize/2 
            textpos.centery = cellHuman[i][1] + cellSize/2
            screen.blit(text, textpos)
            i = i + 1

    def initGridRight(a, colour = (0, 0, 0)):
        "Initialises right-sided grid with values from a, which should be an 81 character string."
        i = 0
        font = pygame.font.Font(None, int(windowWidth * 0.01875))
        while i < 81:
            text = font.render('%s' % a[i], 1, colour)
            textpos = text.get_rect()
            textpos.centerx = cellHuman[i][0] + windowWidth / 2 + cellSize/2
            textpos.centery = cellHuman[i][1] + cellSize/2
            screen.blit(text, textpos)
            i = i + 1

    def emptyGrid(a):
        "Empties grid a (0 for left grid, 1 for right grid)."
        pygame.draw.rect(screen, gridColour, [a * windowWidth/2 + widthBuffer, heightBuffer, 9 * cellSize, 9 * cellSize])
        drawGrid()

    def initCellLeft(a, i):
        "Loads a single cell entry a, into cell i on the left-sided grid."
        font = pygame.font.Font(None, int(windowWidth * 0.01875))
        text = font.render('%s' % a, 1, (0, 0, 0))
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + cellSize/2
        textpos.centery = cellHuman[i][1] + cellSize/2
        screen.blit(text, textpos)

    def initCellRight(a, i, colour = (0, 0, 0)):
        "Loads a single cell entry a, into cell i on the right-sided grid."
        font = pygame.font.Font(None, int(windowWidth * 0.01875))
        text = font.render('%s' % a, 1, colour)
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + windowWidth / 2 + cellSize/2
        textpos.centery = cellHuman[i][1] + cellSize/2
        screen.blit(text, textpos)      
        
#---------------------------------Draw Methods---------------------------------#

## Execution starts here.    
    drawGrid() ## Sets up both grids and dividing line.
    grid = []
    f = open('Puzzles.txt', 'r')
    for line in f:
        grid.append(line)
    f.close()
    puzzleNo = random.randrange(0, len(grid))    
##    print solvedCells
    del solvedCells[:]
    coorMark()
    a = grid[puzzleNo]
    i = 0
    playerSolution = list(a)
    print len(playerSolution)
    print "".join(playerSolution) == a
##    b = solve(a)
##    display(b)
##    print isSolved(decodeDict(b))
    b = genSol(a)
    initGridLeft(a)
    initGridRight(a)
    pygame.display.update()
    value = " "
##    print solvedCells
##    pygame.time.delay(2000)
    initGridRight(a)
    pygame.display.update()
    pygame.time.delay(500)
    
## Event loop, keeps the everything as is until QUIT button is hit.
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == MOUSEBUTTONDOWN:
                if writeButtons(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
##                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    value = writeButtons(pygame.mouse.get_pos())
                    print
                    print value
                    
                elif clearButton(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
##                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    value = clearButton(pygame.mouse.get_pos())
                    print "Clear!"
                    
                elif writing(a, playerSolution, value, pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
##                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
##                    print value, playerSolution
                    if ' ' not in playerSolution:
##                        print playerSolution[0:81]
##                        print list(decodeDict(b))
                        if "".join(playerSolution[0:81]) == decodeDict(b):
                            print
                            compMesg = "Correct Solution!"
                        else:
                            print
                            compMesg = "Sorry :( Wrong Answer"
                        font = pygame.font.Font(None, int(windowWidth * 0.01875))
                        text = font.render('%s' % compMesg, 1, (0, 0, 0))
                        textpos = text.get_rect()
                        textpos.centerx = (windowWidth/2)/2
                        textpos.centery = heightBuffer/2
                        screen.blit(text, textpos) 
                    
                elif RESET(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "Reset!"
                    emptyGrid(0)
                    initGridLeft(a)
                    pygame.display.update()
                    
##                elif SOLUTION(pygame.mouse.get_pos()):
##                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
##                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
##                    print
##                    print "Solution"
##                    initGridRight(decodeDict(b), (150, 150, 150))
##                    initGridRight(a)
##                    pygame.display.update()
                    
                elif PREVIOUSPUZZLE(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "Old Puzzle!" 
                    del solvedCells[:]
                    emptyGrid(0) 
                    emptyGrid(1)
                    if puzzleNo == 0:
                        puzzleNo = len(grid) - 1
                    else:
                        puzzleNo = puzzleNo - 1
                    a = grid[puzzleNo]
                    i = 0
                    playerSolution = list(a)
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                    
                elif NEXTPUZZLE(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "New Puzzle!" 
                    del solvedCells[:]
                    emptyGrid(0)
                    emptyGrid(1)
                    if puzzleNo == len(grid) - 1:
                        puzzleNo = 0
                    else:
                        puzzleNo = puzzleNo + 1
                    a = grid[puzzleNo]
                    i = 0
                    playerSolution = list(a)
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                    
                elif RANDOMPUZZLE(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "Random!" 
                    del solvedCells[:]
                    emptyGrid(0)
                    emptyGrid(1)
                    puzzleNo = random.randrange(0, len(grid))
                    a = grid[puzzleNo]                    
                    i = 0
                    playerSolution = list(a)
                    b = genSol(a)
                    initGridLeft(a)
                    initGridRight(a)
                    
                elif QUIT(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "Quitting!"
                    pygame.quit()
                    sys.exit()
                    
                elif NLV(pygame.mouse.get_pos()):
                    pygame.draw.rect(screen, background, [0, 0, windowWidth/2 - 1, heightBuffer - 1])
                    pygame.draw.rect(screen, background, [windowWidth/2 + 1, cellSize + 1, windowWidth/2 - 1, heightBuffer - 2*cellSize])
                    print
                    print "Next Logical Value!"
                    if i == 81:
                        break
                    while list(a)[square2Cell(solvedCells[i][0])] == solvedCells[i][1]:
                        i = i + 1
                    if a[square2Cell(solvedCells[i][0])] == " ":
                        font = pygame.font.Font(None, int(windowWidth * 0.01875))
                        mesg =  solvedCells[i][1] + " in " + solvedCells[i][0]
                        if solvedCells[i][2] == 0:
                            mesg = mesg + " using simple elimination."
                        elif solvedCells[i][2] == 1:
                            mesg = mesg + " using backtracking."
                        else:
                            mesg = mesg + " as no value other than " + solvedCells[i][1] + " fits in that cell."
                        text = font.render('%s' % mesg, 1, (0, 0, 0))
                        textpos = text.get_rect()
                        textpos.centerx = windowWidth/2 + (windowWidth/2)/2
                        textpos.centery = heightBuffer/2
                        screen.blit(text, textpos) 
                        initCellRight(solvedCells[i][1], square2Cell(solvedCells[i][0]), (150, 150, 150))
                        pygame.display.update()
                        pygame.time.delay(100) ## Change TD to Button.                        
                    i = i + 1
                        
##            elif event.type == MOUSEBUTTONUP:
##                if SOLUTION(pygame.mouse.get_pos()):
##                    emptyGrid(1)
##                    initGridRight(a)
##                    j = 0
##                    while j < i:
##                        if j == 81:
##                            break
##                        while list(a)[square2Cell(solvedCells[j][0])] == solvedCells[j][1]:
##                            j = j + 1
##                        if a[square2Cell(solvedCells[j][0])] == " ":
##                            initCellRight(solvedCells[j][1], square2Cell(solvedCells[j][0]), (150, 150, 150))
##                            pygame.display.update() ## Change TD to Button.
##                        j = j + 1
                        
        pygame.display.update()
        fpsLock.tick(fps) ## Refreshes the screen 'fps' times per second.

if __name__ == '__main__':
    main() 
