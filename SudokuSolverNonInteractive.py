#--------------------------------Imports---------------------------------------#
import pygame, sys
from pygame.locals import *
#--------------------------------Imports---------------------------------------#
## Things we need to add:
## - User inputs to the left grid
## - Clear button for left grid
## - Next logical value button
## - Total solve button
## - Buttons to move between puzzles, ideally buttons for 'random', 'next' and
## 'previous' puzzles.

## Things we should consider adding, time permitting:
## - Optional timer
## - Implement sideways solving, i. e., two player sudoku

#----------------------------------Solve Methods-------------------------------#
## This is just auxillary functions to solve puzzles and return strings.
## Most definitions are straight out of Peter Norvgi's method, with
## unnessecary utilities removed. Added method to convert dict to string, since he uses a
## dict to store and print values. String makes it easier to interface to
## pygame display. Removed his main program calls, left two grids and unit test
## to save time on checking initialization and testing cases. A few changes
## still need to be made, most notably to parse_grid() to return the next
## logical conclusion, and how it arrived at that value.


def cross(A, B):
    "Cross product of elements in A and elements in B."
    return [a+b for a in A for b in B]

digits   = '123456789'
rows     = 'ABCDEFGHI'
cols     = digits
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')])
units = dict((s, [u for u in unitlist if s in u])
             for s in squares)
peers = dict((s, set(sum(units[s],[]))-set([s]))
             for s in squares)

def parse_grid(grid):
    """Convert grid to a dict of possible values, {square: digits}, or
    return False if a contradiction is detected."""
    values = dict((s, digits) for s in squares)
    for s,d in grid_values(grid).items():
        if d in digits and not assign(values, s, d):
            return False ## (Fail if we can't assign d to square s.)
    return values

def grid_values(grid):
    "Convert grid into a dict of {square: char} with '0' or '.' or ' ' for empties."
    chars = [c for c in grid if c in digits or c in '0. ']
    assert len(chars) == 81
    return dict(zip(squares, chars))

def decodeDict(values):
    "Converts the dicts generated by the other functions into an 81 character string."
    a = ''
    for r in rows:
        for c in cols:
            a = a + values[r+c]
    return a

def assign(values, s, d):
    """Eliminate all the other values (except d) from values[s] and propagate.
    Return values, except return False if a contradiction is detected."""
    other_values = values[s].replace(d, '')
    if all(eliminate(values, s, d2) for d2 in other_values):
        return values
    else:
        return False

def eliminate(values, s, d):
    """Eliminate d from values[s]; propagate when values or places <= 2.
    Return values, except return False if a contradiction is detected."""
    if d not in values[s]:
        return values ## Already eliminated
    values[s] = values[s].replace(d,'')
    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.
    if len(values[s]) == 0:
        return False ## Contradiction: removed last value
    elif len(values[s]) == 1:
        d2 = values[s]
        if not all(eliminate(values, s2, d2) for s2 in peers[s]):
            return False
    ## (2) If a unit u is reduced to only one place for a value d, then put it there.
    for u in units[s]:
        dplaces = [s for s in u if d in values[s]]
        if len(dplaces) == 0:
            return False ## Contradiction: no place for this value
        elif len(dplaces) == 1:
            # d can only be in one place in unit; assign it there
            if not assign(values, dplaces[0], d):
                return False
    return values

def display(values):
    "Display these values as a 2-D grid."
    width = 1+max(len(values[s]) for s in squares)
    line = '+'.join(['-'*(width*3)]*3)
    for r in rows:
        print ''.join(values[r+c].center(width)+('|' if c in '36' else '')
                      for c in cols)
        if r in 'CF': print line
    print

def solve(grid): return search(parse_grid(grid))

def search(values):
    "Using depth-first search and propagation, try all possible values."
    if values is False:
        return False ## Failed earlier
    if all(len(values[s]) == 1 for s in squares):
        return values ## Solved!
    ## Chose the unfilled square s with the fewest possibilities
    n,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
    return some(search(assign(values.copy(), s, d))
                for d in values[s])

def some(seq):
    "Return some element of seq that is true."
    for e in seq:
        if e: return e
    return False
#----------------------------------Solve Methods-------------------------------#


def main():
#-----------------------------------Inits--------------------------------------#
    pygame.init() ## Initialises Pygame module.
    global fpsLock, screen ## 'screen' is the surface that the entire interface is being rendered on. 'fpslock' is used to maintain 'fps', defined later.
    global cellHuman ## Global list runs through coordinates for each 'human' cell, i. e., cell on the left-sided grid.
    windowHeight = 1080 ## Min. height is 486, min. width is 972. No errors if dimensions are less, but the grids will overlap.
    windowWidth = 1920 ## Every positioning statement uses these values, so all prints will auto - readjust is these values are modified.
    fps = 60 ## Frames per second. Set at 60 because 60 is standard for games, this program doesn't really require it.
    gridColour = (255, 255, 255) ## RGB White
    background = (0, 255, 255) ## RGB Cyan
    black = (0, 0, 0) ## RBG...well, black
    gridLines = (200, 200, 200) ## RGB 'Light Gray'
    gridSize = 486 ## Dimensions of each puzzle
    squareSize = gridSize / 3 ## Dimensions of each 3x3 square (162x162)
    cellSize = squareSize / 3 ## Dimensions of each individual cell (54x54)
    numSize = cellSize / 3 ## Unused (18x18)
    widthBuffer = (windowWidth / 2 - gridSize ) / 2 ## Buffer between the grids, left window margin, right window margin, and dividing line.
    heightBuffer = (windowHeight - gridSize) / 2 ## Buffer between grids, top window margin, and bottom window margin.
    cellHuman = [[heightBuffer, widthBuffer]] ## Initialising coordinate list to the top left corner of the top left cell of the left-sided grid.

## Loop runs through top left corner of each cell of the left-sided grid, stores the coordinates as a two dimensional list in 'cellHuman'.
    i = 1
    while i < 81:
        if i % 9 == 0:            
            cellHuman.append([heightBuffer, cellHuman[len(cellHuman) -1][1] + 54])
        else:
            cellHuman.append([cellHuman[len(cellHuman) -1][0] + 54, cellHuman[len(cellHuman) -1][1]])
        i = i + 1

        
    screen = pygame.display.set_mode((windowWidth, windowHeight), FULLSCREEN) ## Defines the size of the surface generated, remove the # infront of FULLSCREEN to make it, uhh, go fullscreen.
## If you get a syntax error when trying to run FULLSCREEN, count the number of brackets in the statement.
    fpsLock = pygame.time.Clock() ## Initializing the lock on fps, called during run-time event loop to tick 'fps' times per second.
    pygame.display.set_caption("Sudoku Solver") ## Window caption, unimportant if running in FULLSCREEN.
    screen.fill(background) ## Fills the entire surface with colour
## Draws rectangle where our sudoku puzzles will go, to give them a different background.
    pygame.draw.rect(screen, gridColour, [heightBuffer, widthBuffer, gridSize, gridSize]) 
    pygame.draw.rect(screen, gridColour, [windowWidth/2 + heightBuffer, widthBuffer, gridSize, gridSize])
#-----------------------------------Inits--------------------------------------#
#---------------------------------Grid Methods---------------------------------#
    def drawGrid():
        "Draws two 486x486 resolution, 9x9 cell grids, as well as a dividing line in the centre of the surface. The grids are each centred in their respective half of the surface."
## Loops for drawing the inner 'Light Gray' lines. Lines for the border are also drawn, but later overdrawn by black lines.
        for x in range(heightBuffer , heightBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (x, widthBuffer), (x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (heightBuffer, y), (gridSize - 1 + heightBuffer, y))

        for x in range(heightBuffer , heightBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (x, widthBuffer), (x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (heightBuffer, y), (gridSize - 1 + heightBuffer, y))

        pygame.draw.line(screen, black, (windowWidth/ 2, 0), (windowWidth/2, windowHeight)) ## Dividing line in the middle of the screen.
        
## Loops for drawing grid and 3x3 square outlines in black.
        for x in range(heightBuffer , heightBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + x, widthBuffer), (windowWidth/2 + x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, cellSize):
            pygame.draw.line(screen, gridLines, (windowWidth/2 + heightBuffer, y), (windowWidth/2 + gridSize - 1 + heightBuffer, y))
        for x in range(heightBuffer , heightBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (windowWidth/2 + x, widthBuffer), (windowWidth/2 + x, gridSize - 1 + widthBuffer))
        for y in range(widthBuffer, widthBuffer + gridSize + 1, squareSize):
            pygame.draw.line(screen, black, (windowWidth/2 + heightBuffer, y), (windowWidth/2 + gridSize - 1 + heightBuffer, y))
        return None

    def initGridLeft(a):
        "Initialises left-sided grid with values from a, which should be an 81 character string."
## No need to check if len(a) == 81, since functions in SudoModule take care of that.
        i = 0
        font = pygame.font.Font(None, 36) ## Defines text font and size, None is Pygame default.
        while i < 81:
            text = font.render('%s' % a[i], 1, (0, 0, 0)) ## String in a[i] (In this case, it is a single character) is stored in text. Other attributes are anti-aliasing (1 -> On, 0 -> Off) and colour ((0, 0, 0) is RGB Black).
            textpos = text.get_rect()
## The next bit aligns the x, y centres of the text to the centre of the grid, then blits it onto the surface. 
            textpos.centerx = cellHuman[i][0] + 27 
            textpos.centery = cellHuman[i][1] + 27
            screen.blit(text, textpos)
            i = i + 1

    def initGridRight(a):
        "Initialises right-sided grid with values from a, which should be an 81 character string."
        i = 0
        font = pygame.font.Font(None, 36)
        while i < 81:
            text = font.render('%s' % a[i], 1, (0, 0, 0))
            textpos = text.get_rect()
            textpos.centerx = cellHuman[i][0] + windowWidth / 2 + 27
            textpos.centery = cellHuman[i][1] + 27
            screen.blit(text, textpos)
            i = i + 1

    def emptyGrid(a):
        "Empties grid a (0 for left grid, 1 for right grid)."
        pygame.draw.rect(screen, gridColour, [a * windowWidth/2 + heightBuffer, widthBuffer, gridSize, gridSize])
        drawGrid()

    def initCellLeft(a, i):
        "Loads a single cell entry a, into cell i on the left-sided grid."
        font = pygame.font.Font(None, 36)
        text = font.render('%s' % a, 1, (0, 0, 0))
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + 27
        textpos.centery = cellHuman[i][1] + 27
        screen.blit(text, textpos)

    def initCellRight(a, i):
        "Loads a single cell entry a, into cell i on the right-sided grid."
        font = pygame.font.Font(None, 36)
        text = font.render('%s' % a, 1, (0, 0, 0))
        textpos = text.get_rect()
        textpos.centerx = cellHuman[i][0] + windowWidth / 2 + 27
        textpos.centery = cellHuman[i][1] + 27
        screen.blit(text, textpos)
#---------------------------------Grid Methods---------------------------------#

# Execution starts here.    
    drawGrid() ## Sets up both grids and dividing line.
    grid1 = '  3 2 6  9  3 5  1  18 64    81 29  7       8  67 82    26 95  8  2 3  9  5 1 3  '
    grid2 = '4     8 5 3          7      2     6     8 4      1       6 3 7 5  2     1 4      ' 
    grid3 = '8          36      7  9 2   5   7       457     1   3   1    68  85   1  9    4  ' ## 'Hardest sudoku', atleast as of 2012.
    a = grid2 ## Code has three puzzles so far. grid1 is very easy, requiring only parse_grid to solve. grid2 requires breadth first search in addition. grid3 is right above.
    b = decodeDict(solve(a)) ## Solves the puzzle stored in a, converts it from a dict to string, and assign it to b.
    initGridLeft(a)
    pygame.display.update()
    pygame.time.delay(500)
    emptyGrid(0)
    initGridRight(a)
    pygame.display.update()
    pygame.time.delay(500)
    i = 0
    while i < 81:
        if a[i] != b[i]:
            initCellRight(b[i], i)
            pygame.display.update()
            pygame.time.delay(500)
        i = i + 1
    emptyGrid(1)

## Event loop, keeps the everything as is until QUIT button is hit.
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
        pygame.display.update()
        fpsLock.tick(fps) ## Refreshes the screen 'fps' times per second.

if __name__ == '__main__':
    main() 
